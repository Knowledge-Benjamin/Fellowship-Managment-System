import { Request, Response } from 'express';
import bcrypt from 'bcryptjs';
import { z } from 'zod';
import prisma from '../prisma';
import { generateFellowshipNumber } from '../utils/fellowshipNumberGenerator';

const createMemberSchema = z.object({
    fullName: z.string().min(1),
    email: z.string().email(),
    phoneNumber: z.string(),
    gender: z.enum(['MALE', 'FEMALE']),
    isMakerereStudent: z.boolean(),
    regionId: z.string().uuid('Invalid region ID'),
    classificationTagId: z.string().uuid().optional(),
    additionalTagIds: z.array(z.string().uuid()).optional(),
    courseId: z.string().uuid().optional(),
    yearOfStudy: z.number().min(1).max(7).optional(),
    residenceId: z.string().uuid().optional(),
    hostelName: z.string().optional(),
});

// Create new member
export const createMember = async (req: Request, res: Response) => {
    try {
        const validatedData = createMemberSchema.parse(req.body);

        // Check if email already exists
        const existingMember = await prisma.member.findUnique({
            where: { email: validatedData.email },
        });

        if (existingMember) {
            return res.status(400).json({ error: 'Email already registered' });
        }

        // Verify region exists
        const region = await prisma.region.findUnique({
            where: { id: validatedData.regionId },
        });

        if (!region) {
            return res.status(400).json({ error: 'Invalid region' });
        }

        // Generate fellowship number using existing utility
        const fellowshipNumber = await generateFellowshipNumber();

        // Hash the fellowship number to use as default password
        const hashedPassword = await bcrypt.hash(fellowshipNumber, 10);

        // Create member (qrCode is auto-generated by default(uuid()))
        const member = await prisma.member.create({
            data: {
                fullName: validatedData.fullName,
                email: validatedData.email,
                phoneNumber: validatedData.phoneNumber,
                gender: validatedData.gender,
                regionId: validatedData.regionId,
                courseId: validatedData.courseId,
                yearOfStudy: validatedData.yearOfStudy,
                fellowshipNumber,
                password: hashedPassword,
                residenceId: validatedData.residenceId,
                hostelName: validatedData.hostelName,
            },
            select: {
                id: true,
                fullName: true,
                email: true,
                fellowshipNumber: true,
                qrCode: true,
                phoneNumber: true,
                gender: true,
                regionId: true,
                region: {
                    select: {
                        id: true,
                        name: true,
                    },
                },
                course: true,
                yearOfStudy: true,
                role: true,
                createdAt: true,
            },
        });

        // Auto-assign tags based on student classification
        const tagsToAssign: string[] = [];

        if (validatedData.isMakerereStudent) {
            // Auto-assign MAKERERE_STUDENT tag
            const makTag = await prisma.tag.findFirst({
                where: { name: 'MAKERERE_STUDENT', isSystem: true },
            });
            if (makTag) {
                tagsToAssign.push(makTag.id);
            }
        } else if (validatedData.classificationTagId) {
            // Assign selected classification tag (Alumni/Other Campus/Other)
            tagsToAssign.push(validatedData.classificationTagId);
        }

        // Add any additional tags selected by manager
        if (validatedData.additionalTagIds && validatedData.additionalTagIds.length > 0) {
            tagsToAssign.push(...validatedData.additionalTagIds);
        }

        // Create tag assignments
        if (tagsToAssign.length > 0 && req.user) {
            await prisma.memberTag.createMany({
                data: tagsToAssign.map((tagId) => ({
                    memberId: member.id,
                    tagId,
                    assignedBy: req.user!.id,
                    notes: 'Auto-assigned during registration',
                })),
            });
        }

        // Return member with default password for UI display
        res.status(201).json({
            ...member,
            defaultPassword: fellowshipNumber,
        });
    } catch (error) {
        if (error instanceof z.ZodError) {
            return res.status(400).json({ error: 'Invalid data', details: error.issues });
        }
        console.error('Error creating member:', error);
        res.status(500).json({ error: 'Failed to create member' });
    }
};

// Get all members (with optional search and tag filtering)
export const getMembers = async (req: Request, res: Response) => {
    try {
        const { search, tags } = req.query;

        // Parse tag IDs if provided
        const tagIds = tags ? (tags as string).split(',').filter(Boolean) : [];

        let where: any = {};

        // Search filter
        if (search) {
            where.OR = [
                { fullName: { contains: search as string, mode: 'insensitive' as const } },
                { email: { contains: search as string, mode: 'insensitive' as const } },
                { fellowshipNumber: { contains: search as string, mode: 'insensitive' as const } },
            ];
        }

        // Tag filter - members must have ALL specified tags
        if (tagIds.length > 0) {
            where.memberTags = {
                some: {
                    tagId: { in: tagIds },
                    isActive: true,
                },
            };
        }

        const members = await prisma.member.findMany({
            where,
            select: {
                id: true,
                fullName: true,
                email: true,
                phoneNumber: true,
                fellowshipNumber: true,
                qrCode: true,
                gender: true,
                role: true,
                course: true,
                courseRelation: {
                    select: {
                        id: true,
                        name: true,
                        code: true
                    }
                },
                yearOfStudy: true,
                createdAt: true,
                regionId: true, // CRITICAL: Include regionId for filtering
                region: {
                    select: {
                        id: true,
                        name: true,
                    },
                },
                memberTags: {
                    where: { isActive: true },
                    include: {
                        tag: {
                            select: {
                                id: true,
                                name: true,
                                color: true,
                                type: true,
                                isSystem: true,
                            },
                        },
                    },
                    orderBy: {
                        assignedAt: 'desc',
                    },
                },
            },
            orderBy: {
                createdAt: 'desc',
            },
        });

        // Transform to include only tag info (not full memberTag object)
        const membersWithTags = members.map(member => ({
            ...member,
            tags: member.memberTags.map(mt => mt.tag),
            memberTags: undefined, // Remove the join table data
        }));

        res.json(membersWithTags);
    } catch (error) {
        console.error('Error fetching members:', error);
        res.status(500).json({ error: 'Failed to fetch members' });
    }
};
